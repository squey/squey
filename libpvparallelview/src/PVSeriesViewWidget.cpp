//
// MIT License
//
// Â© ESI Group, 2015
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#include <pvparallelview/PVSeriesViewWidget.h>

#include <pvparallelview/PVSeriesView.h>
#include <pvparallelview/PVSeriesViewParamsWidget.h>
#include <pvparallelview/PVSeriesViewZoomer.h>
#include <pvparallelview/PVDisplayViewScatter.h>
#include <pvkernel/widgets/PVRangeEdit.h>
#include <pvkernel/rush/PVNraw.h>
#include <pvkernel/core/qobject_helpers.h>
#include <pvkernel/core/PVProgressBox.h>
#include <inendi/PVSource.h>
#include <pvdisplays/PVDisplayIf.h>

#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>
#include <QSplitter>
#include <QMenu>
#include <QMessageBox>

#include <KF6/KItemModels/klinkitemselectionmodel.h>

#include <memory>

PVParallelView::PVSeriesViewWidget::PVSeriesViewWidget(Inendi::PVView* view,
                                                       PVCol axis,
                                                       QWidget* parent /*= nullptr*/)
    : QWidget(parent), _view(view), _help_widget(this)
{
	// Define help
	setFocusPolicy(Qt::StrongFocus);
	_help_widget.hide();

	_help_widget.initTextFromFile("series view's help", ":help-style");
	_help_widget.addTextFromFile(":help-series-view-navigation");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-hunting");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-series-view-rendering");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-sampling");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-application");

	_help_widget.finalizeText();

	set_abscissa(axis);

	// Subscribe to plotting changes
	_plotting_change_connection = _view->get_parent<Inendi::PVPlotted>()._plotted_updated.connect(
	    [this](const QList<PVCol>& plotteds_updated) {
		    if (_sampler) {
			    std::unordered_set<size_t> updated_timeseries(plotteds_updated.begin(),
			                                                  plotteds_updated.end());
			    PVCore::PVProgressBox::progress(
			        [this, &updated_timeseries](PVCore::PVProgressBox& pbox) {
				        pbox.set_enable_cancel(false);
				        _sampler->resubsample(updated_timeseries);
			        },
			        QObject::tr("Sampling..."), this);
		    }
	    });
	// Subscribe to selection changes
	_selection_change_connection = _view->_update_output_selection.connect([this]() {
		if (_sampler) {
			PVCore::PVProgressBox::progress(
			    [this](PVCore::PVProgressBox& pbox) {
				    pbox.set_enable_cancel(false);
				    _sampler->resubsample();
			    },
			    QObject::tr("Sampling..."), this);
		}
	});
}

void PVParallelView::PVSeriesViewWidget::minmax_changed(const pvcop::db::array& minmax)
{
	PVViewZoomer::Zoom zoom = _zoomer->current_zoom();
	std::tie(zoom.minX, zoom.maxX) = _sampler->minmax_to_ratio(minmax);
	// Fix negative value generated by QDateTime resolution fixed to the millisecond
	zoom.minX = std::max(zoom.minX, (PVViewZoomer::zoom_f)0.);
	_zoomer->reset_and_zoom_in(zoom);
};

void PVParallelView::PVSeriesViewWidget::setup_layout()
{
	auto replaceable = [this](auto** widget_ptr, auto replacer = nullptr) {
		QWidget* widget = *widget_ptr ? *widget_ptr : new QWidget();
		_updaters.push_back([=]() mutable {
			auto new_widget = *widget_ptr;
			if (new_widget != nullptr and widget != new_widget) {
				if constexpr (std::is_same_v<decltype(replacer), std::nullptr_t>) {
					delete widget->parentWidget()->layout()->replaceWidget(widget, new_widget);
				} else {
					replacer();
				}
				widget->deleteLater();
				widget = new_widget;
			}
		});
		return widget;
	};

	if (_params_widget == nullptr) {
		_params_widget = new PVSeriesViewParamsWidget(_abscissa_axis, this);
	}

	if (QWidget::layout()) {
		delete QWidget::layout();
	}

	auto* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);

	auto* series_widget = new QWidget;
	auto* vlayout = new QVBoxLayout;
	vlayout->setContentsMargins(0, 0, 0, 0);

	vlayout->addWidget(replaceable(&_series_tree_widget, nullptr));
	vlayout->addWidget(replaceable(&_selected_series_tree, nullptr));
	series_widget->setLayout(vlayout);

	auto* splitter = new QSplitter(Qt::Horizontal);
	splitter->setSizePolicy(
	    QSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding));
	splitter->addWidget(replaceable(&_zoomer, [splitter, this] { splitter->replaceWidget(0, _zoomer); }));
	splitter->addWidget(series_widget);
	splitter->setContentsMargins(0, 0, 0, 0);
	splitter->setStretchFactor(0, 1);
	splitter->setStretchFactor(1, 0);

	auto* bottom_layout = new QHBoxLayout;
	bottom_layout->addWidget(replaceable(&_range_edit, nullptr));
	bottom_layout->addStretch();
	bottom_layout->addWidget(_params_widget);

	layout->addWidget(splitter);
	layout->addLayout(bottom_layout);

	setLayout(layout);
}

void PVParallelView::PVSeriesViewWidget::update_layout()
{
	if (layout() == nullptr) {
		setup_layout();
	} else {
		for (auto& updater : _updaters) {
			updater();
		}
	}
}

void PVParallelView::PVSeriesViewWidget::set_abscissa(PVCol abscissa)
{
	if (abscissa == PVCol()) {
		update_layout();
		return;
	}
	if (_abscissa_axis == abscissa) {
		return;
	}
	_abscissa_axis = abscissa;

	if (_split_axis == _abscissa_axis) {
		_split_axis = PVCol();
	}

	PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();

	const pvcop::db::array& time = nraw.column(abscissa);

	{
		auto plotteds = _view->get_parent<Inendi::PVSource>().get_children<Inendi::PVPlotted>();
		const auto& plotteds_vector = plotteds.front()->get_plotteds();

		std::vector<pvcop::core::array<uint32_t>> timeseries;
		for (PVCol col(0); col < nraw.column_count(); col++) {
			timeseries.emplace_back(plotteds_vector[col].to_core_array<uint32_t>());
		}

		_sampler.reset(new Inendi::PVRangeSubSampler(
		    time, std::move(timeseries), nraw, _view->get_real_output_selection(),
		    _split_axis == PVCol() ? nullptr : &nraw.column(_split_axis)));
	}
	_plot = new PVSeriesView(*_sampler, PVSeriesView::Backend::Default);
	_plot->set_background_color(QColor(10, 10, 10, 255));

	_zoomer = new PVSeriesViewZoomer(_plot, *_sampler);

	setup_series_tree(abscissa);
	setup_selected_series_tree(abscissa);

	_range_edit = PVWidgets::PVRangeEditFactory::create(
	    _sampler->minmax_time(),
	    std::bind(&PVSeriesViewWidget::minmax_changed, this, std::placeholders::_1));

	QObject::connect(_zoomer, &PVSeriesViewZoomer::zoom_updated, [this](PVViewZoomer::Zoom zoom) {
		_range_edit->set_minmax(_sampler->ratio_to_minmax(zoom.minX, zoom.maxX));
	});

	QObject::connect(
	    _zoomer, &PVSeriesViewZoomer::selection_commit,
	    [&time, &nraw, this](PVViewZoomer::Zoom zoom) {
		    const pvcop::db::array& minmax = _sampler->ratio_to_minmax(zoom.minX, zoom.maxX);
		    _range_edit->set_minmax(minmax);
		    const auto& sorted_indexes = _sampler->sorted_indexes();
		    pvcop::db::range_t selected_range = time.equal_range(minmax, sorted_indexes);
		    const auto& sort = sorted_indexes ? sorted_indexes.to_core_array()
		                                      : pvcop::core::array<pvcop::db::index_t>();
		    Inendi::PVSelection sel(nraw.row_count());
		    sel.select_none(); // Not sur if needed
		    for (size_t i = selected_range.begin; i < selected_range.end; i++) {
			    sel.set_bit_fast(sort ? sort[i] : i);
		    }
		    _view->set_selection_view(sel);
	    });

	update_layout();
}

void PVParallelView::PVSeriesViewWidget::set_split(PVCol split)
{
	if (split == _split_axis or split == _abscissa_axis) {
		return;
	}

	if (split >= _view->get_axes_combination().get_nraw_axes_count()) {
		split = PVCol();
	}

	if (split != PVCol())
	{
		const pvcop::db::array& col_in = _view->get_rushnraw_parent().column(split);
		pvcop::db::array col1_out;
		pvcop::db::array col2_out;

		pvcop::db::algo::distinct(col_in, col1_out, col2_out, _view->get_selection_visible_listing());

		if (col1_out.size() > 100) {
			if (QMessageBox::question(this, QString("Potentially slow operation"),
			                          QString("Selected axis has %L1 distinct values, do you really want to split ?").arg(col1_out.size()))
			    != QMessageBox::Yes) {
				return;
			}
		}
	}

	_split_axis = split;

	PVCore::PVProgressBox::progress(
	    [this, split](PVCore::PVProgressBox& pbox) {
			pbox.set_enable_cancel(false);
		    PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();
		    _sampler->set_split_column(split == PVCol() ? nullptr : &nraw.column(split));
	    },
	    QObject::tr("Splitting..."), this);

	_zoomer->disable_selecting_mode(split != PVCol());

	// Update range widget
	_range_edit = PVWidgets::PVRangeEditFactory::create(
	    _sampler->minmax_time(),
	    std::bind(&PVSeriesViewWidget::minmax_changed, this, std::placeholders::_1));

	setup_series_tree(_abscissa_axis);
	setup_selected_series_tree(_abscissa_axis);

	update_layout();
}

void PVParallelView::PVSeriesViewWidget::select_all_series(bool /*use_axes_combination  = true */)
{
	QAbstractItemModel& model = *_series_tree_widget->model();
	QItemSelection top_selection{model.index(0, 0), model.index(model.rowCount() - 1, 0)};

	_series_tree_widget->selectionModel()->select(top_selection, QItemSelectionModel::Select);
}

void PVParallelView::PVSeriesViewWidget::setup_series_tree(PVCol abscissa)
{
	_tree_model = new PVSeriesTreeModel(_view, *_sampler);
	_selection_model = new QItemSelectionModel(_tree_model);
	_series_tree_widget = new PVSeriesTreeView();

	_tree_model->setParent(_series_tree_widget);
	_series_tree_widget->setModel(_tree_model);
	_series_tree_widget->setSelectionModel(_selection_model);
	_series_tree_widget->disconnect(); // disconnect local signals

	_series_tree_widget->setHeaderHidden(true);

	connect(_series_tree_widget, &PVSeriesTreeView::selection_changed, this,
	        &PVSeriesViewWidget::update_selected_series);

	// connect hunting rectangle
	connect(_zoomer, &PVSeriesViewZoomer::hunt_commit, [this](QRect region, bool addition) {
		const QModelIndexList& selected_indexes = _selection_model->selectedIndexes();
		QItemSelection in_region_list;
		for (const QModelIndex& index : selected_indexes) {
			const auto index_id = index.data(Qt::UserRole).value<PVCol>();
			auto parent_index = index.parent();
			if ((parent_index.isValid() or not is_splitted()) and
			    is_in_region(region, index_id)) {
				in_region_list.select(index, index);
				if (is_splitted() and addition) {
					in_region_list.select(parent_index, parent_index);
				}
			}
		}
		// Deselect those not in region unless there would be none left
		if (not in_region_list.empty()) {
			_selection_model->select(in_region_list, addition ? QItemSelectionModel::ClearAndSelect
			                                                  : QItemSelectionModel::Deselect);
		}
	});

	// connect context menu
	_series_tree_widget->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(
	    _series_tree_widget, &QWidget::customContextMenuRequested, this,
	    [this, abscissa](QPoint const& pos) {
		    const QModelIndex& index = _series_tree_widget->indexAt(pos);
		    if (index.parent().isValid()) {
			    return; // not a top level item (aka axis)
		    }
		    auto col = index.data(Qt::UserRole).value<PVCol>();
		    QMenu item_menu;
		    auto scatter_action = new QAction(
		        PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>().toolbar_icon(),
		        "Scatter view with abscissa", &item_menu);
		    connect(scatter_action, &QAction::triggered, [this, abscissa, col] {
			    if (auto container =
			            PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(
			                this)) {
				    container->create_view_widget(
				        PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>(), _view,
				        {abscissa, col});
			    }
		    });
		    item_menu.addAction(scatter_action);
		    item_menu.addSeparator();
		    if (auto container =
		            PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(this)) {
			    PVDisplays::add_displays_view_axis_menu(item_menu, container, _view, col);
		    }
		    item_menu.exec(_series_tree_widget->mapToGlobal(pos));
	    });

	// Setup initial selection
	select_all_series();

	_update_selected_series_resample = false;
	update_selected_series();
	_update_selected_series_resample = true;
}

void PVParallelView::PVSeriesViewWidget::setup_selected_series_tree(PVCol /*abscissa*/)
{
	_selected_series_tree = new PVSeriesTreeView(true /*filtered*/);
	auto* filter_proxy_model = new PVSeriesTreeFilterProxyModel();
	auto* selection_link_model =
	    new KLinkItemSelectionModel(filter_proxy_model, _selection_model);
	filter_proxy_model->setSourceModel(_tree_model);
	filter_proxy_model->setParent(_selected_series_tree);
	_selected_series_tree->setModel(filter_proxy_model);
	_selected_series_tree->setSelectionModel(selection_link_model); // sync selection

	_selected_series_tree->setHeaderHidden(true);
	_selected_series_tree->setMaximumHeight(0);
	_selected_series_tree->setSelectionMode(QAbstractItemView::MultiSelection);

	disconnect(_zoomer, &PVSeriesViewZoomer::cursor_moved, nullptr, nullptr);

	connect(_zoomer, &PVSeriesViewZoomer::cursor_moved, [this, filter_proxy_model](QRect region) {
		if (_zoomer->current_selector_mode() != PVSeriesViewZoomer::SelectorMode::Hunting) {
			return;
		}
		QSet<int> selected_ids;
		for (const QModelIndex& index : _selection_model->selectedIndexes()) {
			const auto index_id = index.data(Qt::UserRole).value<PVCol>();
			if ((index.parent().isValid() or not is_splitted()) and
			    is_in_region(region, index_id)) {
				selected_ids.insert(index_id);
				if (is_splitted()) {
					const auto parent_id = index.parent().data(Qt::UserRole).value<PVCol>();
					selected_ids.insert(parent_id);
				}
			}
		}
		filter_proxy_model->set_selection(selected_ids);
		QItemSelection selection; // Select all
		{
			auto sstm = _selected_series_tree->model();
			selection.select(sstm->index(0, 0), sstm->index(sstm->rowCount() - 1, 0));
			for (int i = 0; i < sstm->rowCount(); ++i) {
				auto p_index = sstm->index(i, 0);
				selection.select(sstm->index(0, 0, p_index),
								sstm->index(sstm->rowCount(p_index) - 1, 0, p_index));
			}
		}
		_selected_series_tree->selectionModel()->select(selection, QItemSelectionModel::Select);
		_selected_series_tree->expandAll();

		auto count = selected_ids.count();
		auto scrollbar = _selected_series_tree->horizontalScrollBar();
		_selected_series_tree->setMaximumHeight(
		    count > 0 ? count * _selected_series_tree->sizeHintForRow(0) +
		                    2 * _selected_series_tree->frameWidth() +
		                    (scrollbar->isVisible() ? scrollbar->height() : 0)
		              : 0);
	});
}

void PVParallelView::PVSeriesViewWidget::update_selected_series()
{
	std::vector<PVSeriesView::SerieDrawInfo> series_draw_order;
	std::unordered_set<size_t> selected_timeseries;
	selected_timeseries.reserve(_sampler->timeseries_count() * _sampler->group_count());
	for (const QModelIndex& index : _series_tree_widget->selectedIndexes()) {
		auto index_id = index.data(Qt::UserRole).value<PVCol>();
		if ((index.parent().isValid() or not is_splitted())) {
			QColor index_color = index.data(Qt::BackgroundRole).value<QBrush>().color();
			series_draw_order.push_back({(size_t)index_id, index_color});
			selected_timeseries.emplace(index_id);
		}
	}
	_sampler->set_selected_timeseries(selected_timeseries);
	if (_update_selected_series_resample) {
		PVCore::PVProgressBox::progress(
		    [this](PVCore::PVProgressBox& pbox) {
			    pbox.set_enable_cancel(false);
			    _sampler->resubsample();
		    },
		    QObject::tr("Sampling..."), this);
	}
	_plot->show_series(std::move(series_draw_order));
	_plot->update();
}

bool PVParallelView::PVSeriesViewWidget::is_in_region(const QRect region, PVCol col) const
{
	const auto min_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - (region.top() + region.height()));
	const auto max_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - region.top());

	const auto& av_ts = _sampler->sampled_timeserie(col);
	for (int pos_x = region.left(); pos_x < region.left() + region.width(); ++pos_x) {
		const auto av_ts_value = av_ts[pos_x] * uint32_t(_zoomer->height());
		if (min_value < av_ts_value and av_ts_value < max_value) {
			return true;
		}
	}
	return false;
}

void PVParallelView::PVSeriesViewWidget::keyPressEvent(QKeyEvent* event)
{
	if (PVWidgets::PVHelpWidget::is_help_key(event->key())) {
		if (_help_widget.isHidden()) {
			_help_widget.popup(this, PVWidgets::PVTextPopupWidget::AlignTop,
			                   PVWidgets::PVTextPopupWidget::ExpandAll);
		}
		return;
	}
	if (event->key() == Qt::Key_A and event->modifiers() & Qt::ControlModifier) {
		if (event->modifiers() & Qt::ShiftModifier) {
			select_all_series(false);
		} else {
			select_all_series();
		}
		return;
	}

	QWidget::keyPressEvent(event);
}

void PVParallelView::PVSeriesViewWidget::enterEvent(QEnterEvent*)
{
	setFocus(Qt::MouseFocusReason);
}

void PVParallelView::PVSeriesViewWidget::leaveEvent(QEvent*)
{
	clearFocus();
}
